
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Election Rooms: Publicly readable, admin-managed
    match /electionRooms/{roomId} {
      allow read: if true;
      allow create: if request.auth != null; // Placeholder: Should be specific admin check
      allow update: if request.auth != null; // Placeholder: Should be specific admin check
                                        // Vote count updates are part of a transaction:
                                        // Allow if trying to update 'positions' and room is 'active'
                                        // or if admin is updating other fields.
                                        // A more granular rule would be:
                                        // if (request.auth != null && resource.data.status == 'active' && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['positions', 'updatedAt'])) ||
                                        //    (request.auth != null && request.auth.token.admin == true); // Example admin custom claim
      allow delete: if request.auth != null; // Placeholder: Should be specific admin check
    }

    // User Votes: Records who voted in which election
    match /userVotes/{voteId} {
      allow read: if false; // Users should not be able to list who voted. Admins might via a trusted backend.
      allow create: if request.auth != null && // User must be "authenticated" (e.g. session started by entering email)
                       get(/databases/$(database)/documents/electionRooms/$(request.resource.data.roomId)).data.status == 'active' &&
                       request.resource.data.roomId != null &&
                       request.resource.data.userEmail != null;
                       // The "vote once" logic is primarily handled by client-side transaction which queries first.
                       // This rule ensures votes are only for active elections.
      allow update: if false;
      allow delete: if false;
    }
  }
}
